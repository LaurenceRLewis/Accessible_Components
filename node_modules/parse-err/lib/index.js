"use strict";

function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
const isError = require('iserror');

// We want to support parsing other fields than the standard:
// <https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Errors>
// <https://github.com/stripe/stripe-node/blob/3c07d851cf897490d8b93dd4457dda0c4c8e667f/lib/Error.js#L33>
const parseErr = function parseErr(err) {
  let fields = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
  if (!isError(err)) {
    throw new Error('`err` must be an Error');
  }
  if (!Array.isArray(fields)) {
    throw new TypeError('`fields` must be an Array');
  }
  const keys = {};
  const arr = new Set([...Object.getOwnPropertyNames(Object.getPrototypeOf(err)), ...Object.getOwnPropertyNames(err)]);
  var _iterator = _createForOfIteratorHelper(arr),
    _step;
  try {
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      const key = _step.value;
      if (typeof err[key] !== 'function') {
        keys[key] = err[key];
      }
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }
  if (!keys.name && err.constructor.name) {
    keys.name = err.constructor.name;
  }

  //
  // recursively call parseErr on err.errors if they are errors
  // this is a common approach to combine multiple errors into one error
  // and then add a property called `errors` to the err object with the array of errors
  // (e.g. packages such as `combine-errors` and `maybe-combine-errors` use this approach)
  //
  if (Array.isArray(err.errors)) {
    keys.errors = err.errors.map(e => {
      if (isError(e)) {
        return parseErr(e, fields);
      }
      return e;
    });
  }
  return Array.isArray(fields) && fields.length > 0 ? keys.filter(key => fields.includes(key)) : keys;
};
module.exports = parseErr;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJpc0Vycm9yIiwicmVxdWlyZSIsInBhcnNlRXJyIiwiZXJyIiwiZmllbGRzIiwiRXJyb3IiLCJBcnJheSIsImlzQXJyYXkiLCJUeXBlRXJyb3IiLCJrZXlzIiwiYXJyIiwiU2V0IiwiT2JqZWN0IiwiZ2V0T3duUHJvcGVydHlOYW1lcyIsImdldFByb3RvdHlwZU9mIiwia2V5IiwibmFtZSIsImNvbnN0cnVjdG9yIiwiZXJyb3JzIiwibWFwIiwiZSIsImxlbmd0aCIsImZpbHRlciIsImluY2x1ZGVzIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJzb3VyY2VzIjpbIi4uL3NyYy9pbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBpc0Vycm9yID0gcmVxdWlyZSgnaXNlcnJvcicpO1xuXG4vLyBXZSB3YW50IHRvIHN1cHBvcnQgcGFyc2luZyBvdGhlciBmaWVsZHMgdGhhbiB0aGUgc3RhbmRhcmQ6XG4vLyA8aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvRXJyb3JzPlxuLy8gPGh0dHBzOi8vZ2l0aHViLmNvbS9zdHJpcGUvc3RyaXBlLW5vZGUvYmxvYi8zYzA3ZDg1MWNmODk3NDkwZDhiOTNkZDQ0NTdkZGEwYzRjOGU2NjdmL2xpYi9FcnJvci5qcyNMMzM+XG5jb25zdCBwYXJzZUVyciA9IChlcnIsIGZpZWxkcyA9IFtdKSA9PiB7XG4gIGlmICghaXNFcnJvcihlcnIpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdgZXJyYCBtdXN0IGJlIGFuIEVycm9yJyk7XG4gIH1cblxuICBpZiAoIUFycmF5LmlzQXJyYXkoZmllbGRzKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2BmaWVsZHNgIG11c3QgYmUgYW4gQXJyYXknKTtcbiAgfVxuXG4gIGNvbnN0IGtleXMgPSB7fTtcbiAgY29uc3QgYXJyID0gbmV3IFNldChbXG4gICAgLi4uT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoT2JqZWN0LmdldFByb3RvdHlwZU9mKGVycikpLFxuICAgIC4uLk9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKGVycilcbiAgXSk7XG4gIGZvciAoY29uc3Qga2V5IG9mIGFycikge1xuICAgIGlmICh0eXBlb2YgZXJyW2tleV0gIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGtleXNba2V5XSA9IGVycltrZXldO1xuICAgIH1cbiAgfVxuXG4gIGlmICgha2V5cy5uYW1lICYmIGVyci5jb25zdHJ1Y3Rvci5uYW1lKSB7XG4gICAga2V5cy5uYW1lID0gZXJyLmNvbnN0cnVjdG9yLm5hbWU7XG4gIH1cblxuICAvL1xuICAvLyByZWN1cnNpdmVseSBjYWxsIHBhcnNlRXJyIG9uIGVyci5lcnJvcnMgaWYgdGhleSBhcmUgZXJyb3JzXG4gIC8vIHRoaXMgaXMgYSBjb21tb24gYXBwcm9hY2ggdG8gY29tYmluZSBtdWx0aXBsZSBlcnJvcnMgaW50byBvbmUgZXJyb3JcbiAgLy8gYW5kIHRoZW4gYWRkIGEgcHJvcGVydHkgY2FsbGVkIGBlcnJvcnNgIHRvIHRoZSBlcnIgb2JqZWN0IHdpdGggdGhlIGFycmF5IG9mIGVycm9yc1xuICAvLyAoZS5nLiBwYWNrYWdlcyBzdWNoIGFzIGBjb21iaW5lLWVycm9yc2AgYW5kIGBtYXliZS1jb21iaW5lLWVycm9yc2AgdXNlIHRoaXMgYXBwcm9hY2gpXG4gIC8vXG4gIGlmIChBcnJheS5pc0FycmF5KGVyci5lcnJvcnMpKSB7XG4gICAga2V5cy5lcnJvcnMgPSBlcnIuZXJyb3JzLm1hcCgoZSkgPT4ge1xuICAgICAgaWYgKGlzRXJyb3IoZSkpIHtcbiAgICAgICAgcmV0dXJuIHBhcnNlRXJyKGUsIGZpZWxkcyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBlO1xuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIEFycmF5LmlzQXJyYXkoZmllbGRzKSAmJiBmaWVsZHMubGVuZ3RoID4gMFxuICAgID8ga2V5cy5maWx0ZXIoKGtleSkgPT4gZmllbGRzLmluY2x1ZGVzKGtleSkpXG4gICAgOiBrZXlzO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBwYXJzZUVycjtcbiJdLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQSxNQUFNQSxPQUFPLEdBQUdDLE9BQU8sQ0FBQyxTQUFTLENBQUM7O0FBRWxDO0FBQ0E7QUFDQTtBQUNBLE1BQU1DLFFBQVEsR0FBRyxTQUFYQSxRQUFRLENBQUlDLEdBQUcsRUFBa0I7RUFBQSxJQUFoQkMsTUFBTSx1RUFBRyxFQUFFO0VBQ2hDLElBQUksQ0FBQ0osT0FBTyxDQUFDRyxHQUFHLENBQUMsRUFBRTtJQUNqQixNQUFNLElBQUlFLEtBQUssQ0FBQyx3QkFBd0IsQ0FBQztFQUMzQztFQUVBLElBQUksQ0FBQ0MsS0FBSyxDQUFDQyxPQUFPLENBQUNILE1BQU0sQ0FBQyxFQUFFO0lBQzFCLE1BQU0sSUFBSUksU0FBUyxDQUFDLDJCQUEyQixDQUFDO0VBQ2xEO0VBRUEsTUFBTUMsSUFBSSxHQUFHLENBQUMsQ0FBQztFQUNmLE1BQU1DLEdBQUcsR0FBRyxJQUFJQyxHQUFHLENBQUMsQ0FDbEIsR0FBR0MsTUFBTSxDQUFDQyxtQkFBbUIsQ0FBQ0QsTUFBTSxDQUFDRSxjQUFjLENBQUNYLEdBQUcsQ0FBQyxDQUFDLEVBQ3pELEdBQUdTLE1BQU0sQ0FBQ0MsbUJBQW1CLENBQUNWLEdBQUcsQ0FBQyxDQUNuQyxDQUFDO0VBQUMsMkNBQ2VPLEdBQUc7SUFBQTtFQUFBO0lBQXJCLG9EQUF1QjtNQUFBLE1BQVpLLEdBQUc7TUFDWixJQUFJLE9BQU9aLEdBQUcsQ0FBQ1ksR0FBRyxDQUFDLEtBQUssVUFBVSxFQUFFO1FBQ2xDTixJQUFJLENBQUNNLEdBQUcsQ0FBQyxHQUFHWixHQUFHLENBQUNZLEdBQUcsQ0FBQztNQUN0QjtJQUNGO0VBQUM7SUFBQTtFQUFBO0lBQUE7RUFBQTtFQUVELElBQUksQ0FBQ04sSUFBSSxDQUFDTyxJQUFJLElBQUliLEdBQUcsQ0FBQ2MsV0FBVyxDQUFDRCxJQUFJLEVBQUU7SUFDdENQLElBQUksQ0FBQ08sSUFBSSxHQUFHYixHQUFHLENBQUNjLFdBQVcsQ0FBQ0QsSUFBSTtFQUNsQzs7RUFFQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQSxJQUFJVixLQUFLLENBQUNDLE9BQU8sQ0FBQ0osR0FBRyxDQUFDZSxNQUFNLENBQUMsRUFBRTtJQUM3QlQsSUFBSSxDQUFDUyxNQUFNLEdBQUdmLEdBQUcsQ0FBQ2UsTUFBTSxDQUFDQyxHQUFHLENBQUVDLENBQUMsSUFBSztNQUNsQyxJQUFJcEIsT0FBTyxDQUFDb0IsQ0FBQyxDQUFDLEVBQUU7UUFDZCxPQUFPbEIsUUFBUSxDQUFDa0IsQ0FBQyxFQUFFaEIsTUFBTSxDQUFDO01BQzVCO01BRUEsT0FBT2dCLENBQUM7SUFDVixDQUFDLENBQUM7RUFDSjtFQUVBLE9BQU9kLEtBQUssQ0FBQ0MsT0FBTyxDQUFDSCxNQUFNLENBQUMsSUFBSUEsTUFBTSxDQUFDaUIsTUFBTSxHQUFHLENBQUMsR0FDN0NaLElBQUksQ0FBQ2EsTUFBTSxDQUFFUCxHQUFHLElBQUtYLE1BQU0sQ0FBQ21CLFFBQVEsQ0FBQ1IsR0FBRyxDQUFDLENBQUMsR0FDMUNOLElBQUk7QUFDVixDQUFDO0FBRURlLE1BQU0sQ0FBQ0MsT0FBTyxHQUFHdkIsUUFBUSJ9